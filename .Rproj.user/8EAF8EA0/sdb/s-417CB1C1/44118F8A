{
    "collab_server" : "",
    "contents" : "#' Calculate the repeated measures correlation coefficient.\n#' \n#' @param participant A variable giving the subject name/id for each observation.\n#' @param measure1 A numeric variable giving the observations for one measure.\n#' @param measure2 A numeric variable giving the observations for the second measure.\n#' @param dataset The data frame containing the variables.\n#' @param CIs The method of calculating confidence intervals.\n#' @param nreps The number of resamples to take if bootstrapping.\n#' @param bstrap.out Determines if the output include the bootstrap resamples.\n#' @return A list with class \"rmc\" containing the following components.\n#' \\item{r}{the value of the repeated measures correlation coefficient.}\n#' \\item{df}{the degrees of freedom}\n#' \\item{p}{the p-value for the repeated measures correlation coefficient.}\n#' \\item{CI}{the 95\\% confidence interval for the repeated measures correlation coefficient.}\n#' \\item{model}{the multiple regression model used to calculate the correlation coefficient.}\n#' \\item{resamples}{the bootstrap resampled correlation values.}\n#' @seealso \\code{\\link{plot.rmc}}\n#' @examples\n#' ## Bland Altman 1995 data\n#' rmcorr(Subject, PacO2, pH, bland1995)\n#' @export\n\n\nrmcorr <- function(participant, measure1, measure2, dataset, \n                   CIs = c(\"analytic\", \"bootstrap\"), \n                   nreps = 100, bstrap.out = F) {\n    \n    options(contrasts = c(\"contr.sum\", \"contr.poly\"))\n    \n    args <- as.list(match.call())\n    \n    Participant <- eval(args$participant, dataset)\n    if (!is.factor(Participant)) \n    {\n        Participant <- factor(Participant)\n        warning(\"Participant coerced into a factor\")\n    }\n    \n    Measure1 <- eval(args$measure1, dataset)\n    Measure2 <- eval(args$measure2, dataset)\n    if (!is.numeric(Measure1) || !is.numeric(Measure2))\n        stop(\"'Measure 1' and 'Measure 2' must be numeric\")\n    \n    CIs <- match.arg(CIs)\n    \n    lmmodel <- stats::lm(Measure2 ~ Participant + Measure1)\n    lmslope <- stats::coef(lmmodel)[\"Measure1\"]\n    errordf <- lmmodel$df.residual\n    \n    # Direction of correlation based on whether slope is positive or negative  \n    corrsign <- sign(lmslope)  \n    \n    # Drop each term for Type III sums of squares\n    type3rmcorr <- stats::drop1(lmmodel, ~., test=\"F\" )\n    SSFactor <- type3rmcorr$'Sum of Sq'[3] \n    SSresidual <- type3rmcorr$RSS[1]\n    \n    #correlation coefficient\n    rmcorrvalue <- as.numeric(corrsign * sqrt(SSFactor / (SSFactor + SSresidual)))\n    \n    # Pvalue and confidence intervals\n    pvalue <- type3rmcorr$'Pr(>F)'[3]\n    \n    #analytic\n    resamples <- NULL\n    if (CIs == \"analytic\"){\n        rmcorrvalueCI <- psych::r.con(rmcorrvalue, errordf) \n    } else if (CIs == \"bootstrap\") {\n        nsubs <- length(levels(Participant))\n        if (!is.numeric(nreps)){stop(\"Specify the number of bootstrap resamples to take\")}\n        cor.reps <- numeric(nreps)\n        \n        for (i in 1:nreps){\n            bs.1 <- NULL\n            bs.2 <- NULL\n            \n            for (j in 1:nsubs) {\n                subdata <- which(Participant==levels(Participant)[j])\n                resamp <- sample(subdata,length(subdata),replace=T)\n                bs.1 <- c(bs.1,Measure1[resamp])\n                bs.2 <- c(bs.2,Measure2[resamp])\n            }\n            \n            bs.Part <- Participant\n            repmodel<-stats::lm(bs.1 ~ bs.Part + bs.2)\n            repslope <- stats::coef(repmodel)[\"bs.2\"]\n            errordf <- repmodel$df.residual\n            repsign <- sign(repslope)  \n            \n            type3rmcorr<-stats::drop1(repmodel, ~., test=\"F\" )\n            SSFactor<-type3rmcorr$'Sum of Sq'[3] \n            SSresidual<-type3rmcorr$RSS[1]\n            \n            cor.reps[i] <- as.numeric(repsign*sqrt(SSFactor/(SSFactor+SSresidual)))\n        }\n        rmcorrvalueCI <- stats::quantile(cor.reps,probs=c(.025,.975))\n        resamples <- cor.reps\n    }\n    \n    \n    \n    rmoutput <- list(r = rmcorrvalue, df = errordf, p = pvalue, \n                     CI = rmcorrvalueCI, model = lmmodel, \n                     vars = as.character(c(args$participant,args$measure1,args$measure2)))\n    if (bstrap.out) {rmoutput$resamples <- resamples}\n    class(rmoutput) <- \"rmc\"\n    return (rmoutput)\n} \n\n\n#' Calculate the repeated measures correlation coefficient.\n#' \n#' @param x An object of class \"rmc\", a result of a call to rmcorr.\n#' @param ... additional arguments to \\code{\\link[base]{print}}.\n#' @seealso \\code{\\link{rmcorr}}\n#' @examples\n#' ## Bland Altman 1995 data\n#' blandrmc <- rmcorr(Subject, PacO2, pH, bland1995)\n#' blandrmc\n#' @export\n\nprint.rmc <- function(x, ...) {\n    cat(\"\\nRepeated measures correlation\\n\\n\")\n    cat(\"r\\n\")\n    cat(x$r)\n    cat(\"\\n\\ndegrees of freedom\\n\")\n    cat(x$df)\n    cat(\"\\n\\np-value\\n\")\n    cat(x$p)\n    cat(\"\\n\\n95% confidence interval\\n\")\n    cat(x$CI)\n    \n}   \n    \n    ",
    "created" : 1432147886169.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "534058996",
    "id" : "44118F8A",
    "lastKnownWriteTime" : 1472493714,
    "last_content_update" : 1472493714638,
    "path" : "C:/Users/Laura Cooper/Desktop/Need from Laptop/rmcorr package/rmcorr/R/rmcorr.R",
    "project_path" : "R/rmcorr.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}