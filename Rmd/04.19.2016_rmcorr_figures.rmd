---
title: "Reproduce results of rmcorr paper"
author: "Jon Bakdash and Laura Marusich"
date: "April 19, 2016"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

```{r, echo=FALSE}
require(pwr)
require(psych) 
require(Hmisc)
require(RColorBrewer)
require(grDevices)
require(plotrix)
require(metafor)
library(rmcorr)
require(devtools) #Comment out in final version
require(lme4)
require(AICcmodavg)
require(MuMIn)
#install_github('lmarusich/rmcorr')

#require(checkpoint)
#checkpoint("2016-XX-YY") #Won't work yet b/c rmcorr doesn't yet exist in CRAN
#require(memoise)

```

###1. Figure 1: rmcorr and reg plot

###2. Figure 2: rmcorr w/data transformations

###3. Figure 3: rmcorr vs OLS reg

###4. Figure 4: Power curves 
```{r, echo=FALSE, fig.height = 8, fig.width = 8}
power.rmcorr<-function(k, N, effectsizer, sig)
    {
    pwr.r.test(n = ((N)*(k-1))+1, r = effectsizer, sig.level = sig) 
    #df are specified this way because pwr.r.test assumes the input is N, so it uses N - 2 for the df
    }

par(mfrow=c(1,3), cex.lab=1.25, cex.axis=1.25, cex.main=1.25, cex.sub=1.25, mar=c(4.5,4.5,1.75,1))
  
#Small effect size
  k<-c(3, 5, 10, 20) 
  nvals <- seq(6, 300)
  powPearsonSmall <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.1)$power)
  
  bluecolors<-c("#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594")
  #bluecols<-brewer.pal(9, "Blues")
  #bluecols3<-c(greenscols[6], bluecols[2],bluecols[3],bluecols[5],bluecols[7],bluecols[9])
  

 
  plot(nvals, seq(0,1, length.out=length(nvals)), 
       main = expression(bold("a)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.10')), 
       xlab=expression(Sample~Size~"("*italic('N')*")"),
       yaxt = "n", ylab = "Power", las = 1, col = "white", 
       xlim=c(0,300))
  
  yLabels <- seq(0, 1, 0.2)
  axis(2, at=yLabels, labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1, cex.sub = 2)
  
  for (i in 1:4) 
    {
    powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.1, 0.05)$power)
    lines(nvals, powvals, lwd=2.5, col=bluecolors[i+1])
    }
  legend("bottomright", lwd=2.5, col=bluecolors, bty= 'n', legend=c("1", "3", "5", "10", "20"), title = expression(italic('k')),
         cex = 1.2)
  lines(nvals, powPearsonSmall, col=bluecolors[1], lwd= 2.5)
  abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)

#Medium effect size
  k<-c(3, 5, 10, 20)
  nvals <- seq(6, 50)
  powPearsonMedium <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.3)$power)
  greencolors<-c("#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#005a32")
  
  #orangecols<-brewer.pal(9, "Oranges")
  #orangecols3<-c(orangecols[2],orangecols[3],orangecols[5],orangecols[7],orangecols[9])
  
  plot(nvals, seq(0,1, length.out=length(nvals)), 
       main = expression(bold("b)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.30')), 
       xlab=expression(Sample~Size~"("*italic('N')*")"),
       yaxt = "n", ylab = "Power", las = 1, col = "white", 
       xlim=c(0,50))
  
  yLabels <- seq(0, 1, 0.2)
  axis(2, at=yLabels, main = "Power", labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1)
  
  for (i in 1:4) 
  {
    powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.3, 0.05)$power)
    lines(nvals, powvals, lwd=2.5, col=greencolors[i+1])
  }
  legend("bottomright", lwd=2, col=greencolors, bty = 'n', legend=c("1", "3", "5", "10", "20"), title = expression(italic('k')),
         cex = 1.2)
  lines(nvals, powPearsonMedium, col=greencolors[1], lwd = 2.5)
  abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)
  
#Large effect size
  k<-c(3, 5, 10, 20)
  nvals <- seq(6, 30)
  powPearsonlarge <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.5)$power)
  
  purplecolors<-c("#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486")
  
  plot(nvals, seq(0,1, length.out=length(nvals)), 
        main = expression(bold("c)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.50')),
       xlab=expression(Sample~Size~"("*italic('N')*")"),
       yaxt = "n", ylab = "Power", las = 1, col = "white", xlim=c(0,30))
  yLabels <- seq(0, 1, 0.2)
  axis(2, at=yLabels, main = "Power", labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1)
  
  for (i in 1:4) 
  {
    powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.5, 0.05)$power)
    lines(nvals, powvals, lwd=2.5, col=purplecolors[i+2])
  }
  legend("bottomright", lwd=2, col=purplecolors, legend=c("1", "3", "5", "10", "20"), bty = 'n', title = expression(italic('k')),
         cex = 1.2)
  abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)
  lines(nvals, powPearsonlarge, col=purplecolors[2], lwd = 2.5)

dev.copy(pdf, file="plots/Figure4_Power_curves.pdf", 8, 8)
dev.off()

```

###5. Visual search rmcorr and simple reg/cor results and Figure 5
#### a) rmcorr and simple reg results
```{r, echo=FALSE}
vissearch.rmc <- rmcorr(participant = sub, measure1 = rt, measure2 = acc, dataset = gilden2010)
print(vissearch.rmc)

vissearch.lm<-lm(acc~rt, data = gilden2010)
print(vissearch.lm)

cor.test(gilden2010$rt, gilden2010$acc)
```

#### b) Figure 5: Visual search rmcorr and simple reg/cor
```{r, echo=FALSE, fig.width = 9, fig.height = 6}

par(mfrow=c(1,2), mar=c(5,4.6,4,0.5), mgp=c(3.2,0.8,0),  oma = c(0, 0, 0, 0), las = 1)

plot(vissearch.rmc, gilden2010, overall = F, xlab = "Reaction Time", ylab = "Accuracy", cex = 1.2, 
     main = expression(bold("a)")~bold('Rmcorr'))) 
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")

plot(acc~rt, data = gilden2010, xlab = "Reaction Time (seconds)", ylab = "Accuracy", cex = 1.2, pch = 16,
     main = ("b) Simple Regression/\nCorrelation"))
     abline(vissearch.lm, col = "red", lwd = 2)
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure5_Visual_Search.pdf", 9, 6)
dev.off()
```

###6. Complete pooling examples (fit a single model to all data points) using regression: Size and Distance
##### a) Regression Results 
```{r, echo = FALSE}
SizeDistPoolAll.lm<-lm(Emmert_distance_meters~Perceived_dist, data = Size_distance)
print(SizeDistPoolAll.lm)
summary(SizeDistPoolAll.lm)

#Complete Pooling by block: Single model fit to data averaged by block, by participant 
BlockSizeDistance<-aggregate(cbind(Emmert_distance_meters, Perceived_dist) ~ Actual_dist_meters + Participant, FUN = mean, data=Size_distance)
SizeDistBlock.lm<-lm(Emmert_distance_meters~Perceived_dist , data = BlockSizeDistance)
print(SizeDistBlock.lm)
summary(SizeDistBlock.lm)
```

##### b) Figure 6
```{r, echo = FALSE, fig.width = 9, fig.height = 6}
par(mfrow=c(1,2), mar=c(5,4.6,4,0.5), mgp=c(3.2,0.8,0),  oma = c(0, 0, 0, 0), las = 1)

plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16, 
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "Complete Pooling: All Data",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance (m)", 
     las = 1) 
     abline(SizeDistPoolAll.lm, col = "red", lwd = 2)
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")
     
SizeDistBlock.lm
plot(Emmert_distance_meters~Perceived_dist, data = BlockSizeDistance, pch = 16, 
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "Complete Pooling: \nAveraged by Block, by Participant",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance (m)", 
     las = 1) 
     abline(SizeDistBlock.lm, col = "red", lwd = 2)
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")
     
dev.copy(pdf, file="plots/Figure6_CompletePooling.pdf", 9, 6)  
dev.off()
```  

###7. No pooling (no overall predictor, "separate" models for each participant) using regression: Size and distance 
##### a)  Multiple Regression: Different intercepts for each participant, common slope 
```{r, echo = FALSE}    
#No constant term (-1) so all participants are included 
SizeDistNoPool.lm<-lm(Emmert_distance_meters~Perceived_dist + factor(Participant) - 1, data = Size_distance)
print(SizeDistNoPool.lm)
summary(SizeDistNoPool.lm)

# #Separate models for each actual dist, quasi-piecewise/segmented regression  
# Break2<-subset(Size_distance, Actual_dist_meters == 2)
# Break4<-subset(Size_distance, Actual_dist_meters == 4)
# Break6<-subset(Size_distance, Actual_dist_meters == 6)
# 
# SizeDistNoPoolBreak2.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break2)
# print(SizeDistNoPoolBreak2.lm)
# summary(SizeDistNoPoolBreak2.lm)
# 
# SizeDistNoPoolBreak4.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break4)
# print(SizeDistNoPoolBreak4.lm)
# summary(SizeDistNoPoolBreak4.lm)
# 
# SizeDistNoPoolBreak6.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break6)
# print(SizeDistNoPoolBreak6.lm)
# summary(SizeDistNoPoolBreak6.lm)
# 
# 
# plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16, 
#      col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
#      main = "Separate Regressions of Actual Distance:\n Emmert Distance and Perceived Distance",
#      ylab = "Emmert Distance (m)",
#      xlab = "Perceived Distance\n(m)", 
#      las = 1) 
# curve(1.5336 + 0.2851*x, add = TRUE, from = min(Break2$Perceived_dist), to = max(Break2$Perceived_dist))
# curve(3.0811 + 0.3387*x, add = TRUE, from = min(Break4$Perceived_dist), to = max(Break4$Perceived_dist))
# curve(5.6731 + 0.1786*x, add = TRUE, from = min(Break6$Perceived_dist), to = max(Break6$Perceived_dist))
# ```

##### b) Figure 7
```{r, echo = FALSE, fig.width = 8, fig.height = 8}
#Wish list: Each regression line clipped by range of participant data, points and lines matched by participant 
plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16, 
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "No Pooling:\nRegression of Emmert Distance and Perceived Distance",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", 
     las = 1) 
     #Unique intercept per participant, the same slope
     for (i in 2:21) abline(SizeDistNoPool.lm$coef[i], SizeDistNoPool.lm$coef[1], col = "red", lwd = 2)
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure7_NoPooling.pdf", 8, 8)  
dev.off()

#Another wish list item
#Separate models: Separate regression for each participant (another form of no pooling), 
#same as above except each individual has their own slope 
```

###8. Emmert Distance (size) and distance rmcorrs 
##### a) Three separate rmcorr
```{r, echo=TRUE}

#Subset the data first
  Size_distance_actual2<-subset(Size_distance, Actual_dist_meters==2)
  Size_distance_actual4<-subset(Size_distance, Actual_dist_meters==4)   
  Size_distance_actual6<-subset(Size_distance, Actual_dist_meters==6)

#Seperate rmcorr on each actual distance (factor level)
  Distance_EmmertDist2.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, measure2 = Emmert_distance_meters, dataset = Size_distance_actual2)
  Distance_EmmertDist2.rmc
  
  Distance_EmmertDist4.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, 
                                     measure2 = Emmert_distance_meters, dataset = Size_distance_actual4)
  Distance_EmmertDist4.rmc
  
  Distance_EmmertDist6.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, 
                                     measure2 = Emmert_distance_meters, dataset = Size_distance_actual6)
  Distance_EmmertDist6.rmc
```

##### b) Figure 8: Emmert Distance (size) and distance rmcorrs 
```{r, echo=FALSE, fig.width = 10, fig.height = 5}

par(mfrow=c(1,3), cex.lab=1.1, cex.axis=1.1, cex.main=1.1, cex.sub = 1.1, mgp=c(3.2,0.8,0))
#par(mfrow=c(1,3), mar=c(5,5,4,0.75), oma=c(0,2,0,0), mgp=c(3.2,0.80,0), cex.lab=1.2, cex.axis=1.1, cex.main=1.2, cex.sub=1.15)

Blues<-(brewer.pal(9,'Blues'))
pal1<-colorRampPalette(Blues)

Oranges<-(brewer.pal(9,'Oranges'))
pal2<-colorRampPalette(Oranges)

Greens<-(brewer.pal(9,'Greens'))
pal3<-colorRampPalette(Greens)

plot(Distance_EmmertDist2.rmc, Size_distance_actual2, overall = FALSE,
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(1,3), xlim = c(1,3), palette = pal1,
     main = ("a) Actual Distance\n2m"), cex = 1.2)
     axis.break(axis = 1, style = "slash", brw = 0.0125)
     axis.break(axis = 2, style = "slash", brw = 0.0125)

plot(Distance_EmmertDist4.rmc, Size_distance_actual4, overall = FALSE,       
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(2,7), xlim = c(2,6), palette = pal2,
     main = ("b) Actual Distance\n4m"), cex = 1.2)
     axis.break(axis = 1, style = "slash", brw = 0.0125)
     axis.break(axis = 2, style = "slash", brw = 0.0125)

plot(Distance_EmmertDist6.rmc, Size_distance_actual6, overall = FALSE, 
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(2,11), xlim = c(3,9), palette = pal3,
     main = ("c) Actual Distance\n6m"), cex = 1.2)
     axis.break(axis = 1, style = "slash", brw = 0.0125)
     axis.break(axis = 2, style = "slash", brw = 0.0125)
     
dev.copy(pdf, file="plots/Figure8_size_dist_sep.pdf", 10, 5)     
dev.off()  

```

###9. Forest plot of separate rmcorrs 
```{r, echo=FALSE, fig.width = 9, fig.height = 6}

yi<-c(Distance_EmmertDist2.rmc$r, Distance_EmmertDist4.rmc$r, Distance_EmmertDist6.rmc$r)
ni<-rep(101, length.out = 3)
effectlabels<-c("Actual Distance 2m","Actual Distance 4m", "Actual Distance 6m")
DistMeta<-data.frame(cbind(effectlabels, as.numeric(yi), as.numeric(ni)))

#Parametric Confidence Intervals
dev <-escalc(ri = yi, ni = ni, measure="ZCOR", method ="REML", data = DistMeta, append = FALSE)
devRE <- rma(yi, vi, data = dev)
confint(devRE)
summary(devRE)
 
Figure7<-forest(devRE, slab = effectlabels, mlab = "Overall (Random Effects Model)",
         xlab = expression("Repeated Measures Correlation Coefficient"~"("*italic('r'[rm])*")")) 
         text(-0.88, 5, "Factor Level", pos = 1, font = 2)
         text(0.70, 5, expression(italic(r)[rm] ~~ "[95% CI]"), pos = 1, font = 2)

dev.copy(pdf, file="plots/Figure9_Forest.pdf", 9, 6)  
dev.off()

```

###10. Complete pooling of size and distance using rmcorr overall (ignoring factor levels of actual distance) 
##### a) rmcorr results
```{r, echo=FALSE}
#Seperate rmcorr on each actual distance (factor level)
Distance_EmmertDist_Overall.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, measure2 = Emmert_distance_meters, dataset = Size_distance)
Distance_EmmertDist_Overall.rmc
```

##### b) Figure 10: rmcorr FLOP 
```{r, echo=FALSE, fig.width = 9, fig.height = 6}
#Palette different than 9? 
#pal4<-colorRampPalette(brewer.pal(9,'Reds'))(20) 
pal4<-colorRampPalette(brewer.pal(9,"Reds"))

par(cex.lab=1.2, cex.axis=1.2, cex.main=1.2, cex.sub=1.2, mar=c(6,5.5,4,3.5), oma=c(1,1,1,1), mgp = c(4, 1, 0))
Figure8<-plot(Distance_EmmertDist_Overall.rmc, Size_distance, overall = FALSE,
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, palette = pal4,
     main = ("Rmcorr Ignoring Factor Levels"))
     axis.break(axis = 1, style = "slash")
     axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure10_FLOP_rm_overall.pdf", 9, 6)  
dev.off()

```

###10. Multi-level modeling of size and distance data 
##### a) Multi-level modeling and model comparison
```{r, echo=FALSE}

#Knitting the Rmd throws errors with data = ... in lmer, even though it works fine as a script. No clue why????
#NullModel<-lmer(Emmert_distance_meters ~  1 + (1|Participant), data = Size_distance, REML = FALSE)
#Note actual_dist_meters has only 3 levels, very spare for random effect. Not specified as an RE here.

#Clunky Rmd safe version
#Random Int (Participant) only
NullModel<-lmer(Size_distance$Emmert_distance_meters ~  1 + (1 | Size_distance$Participant), REML = FALSE)

#Model 1: Null + fixed effect actual distance
Model1 <-lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters + 
              (1|Size_distance$Participant), 
              REML = FALSE)

#Model 2: Model 1 + fixed effect perceived distance  
Model2 <-lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters + Size_distance$Perceived_dist + 
             (1|Size_distance$Participant), 
             REML = FALSE)

#Model 3: Model 2 + fixed effect actual distance x  perceived dist (fully crossed)
Model3 <-lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist + 
             (1|Size_distance$Participant), 
             REML = FALSE)

#Model 4: Model 2 plus random int by participant, random effect slope for perceived dist by participant
Model4 <-lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters + Size_distance$Perceived_dist +
             (1| Size_distance$Participant) + 
             (-1+Size_distance$Perceived_dist |  Size_distance$Participant), 
             REML = FALSE)

#Does not converge
#Model 5: Model 3 plus plus random int by participant, random effect int and slope for perceived dist by participant
# Model5 <-lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist +
#              (1| Size_distance$Participant) + 
#              (Size_distance$Perceived_dist |  Size_distance$Participant), 
#              REML = FALSE)

#Model Comparison
anova(NullModel, Model1, Model2, Model3, Model4)

SizeDistModels<-list()
SizeDistModels[[1]]<-NullModel
SizeDistModels[[2]]<-Model1
SizeDistModels[[3]]<-Model2
SizeDistModels[[4]]<-Model3
SizeDistModels[[5]]<-Model4

ModelTable<-aictab(SizeDistModels, modnames = c("Null", "Model 1", "Model 2", "Model 3", "Model 4"))
ModelTable
evidence(ModelTable)

#Pseudo R2s
r.squaredGLMM(NullModel)
r.squaredGLMM(Model1)
r.squaredGLMM(Model2)
r.squaredGLMM(Model3)
r.squaredGLMM(Model4)
#
# Model3FitFE<-fitted(Model3)
#Model3FitRE<-predict(Model3, re.form = ~0)
# plot(Model3, ranef(.,standard = TRUE)~Participant, abline = 0)

#Good lmer plotting ref: AdvPlot_HO.pdf

```

##### b) Graph best fit model: Model 4

##Appendix: Rmcorr minus standard corr power 

```{r, echo=FALSE}
k<-2
nvals <- seq(8, 250)
powPearsonLarge <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.5)$power)
#bluecolors<-c("#c6dbef", "#9ecae1")

par(mfrow=c(1,1), cex.lab=1.1, cex.axis=1.1, cex.main=1.2, cex.sub=1.2)
AppendFig1<-plot(nvals, seq(0,1, length.out=length(nvals)), 
            xlab="Sample Size", yaxt = "n", ylab = paste("Power Difference:",  "Rmcorr (k = 2)", " -", " Pearson correlation"), las = 1, col = "white", xlim=c(0,250), ylim=c(0,0.05))
            yLabels <- seq(0, 0.2, 0.01)
            axis(2, at=yLabels, labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1, cex.sub = 2)

powvals <- sapply(nvals, function (x) power.rmcorr(k[1], x, 0.5, 0.05)$power)
powvalsdiff<-as.numeric(powvals) - as.numeric(powPearsonLarge)
lines(nvals, powvalsdiff, lwd=2.5, col="red")

dev.copy(pdf, file="plots/Appendix_Figure.pdf", 9, 6) 
dev.off()
``` 

## Standard Correlation Power Curve (not in paper)
```{r, echo=FALSE}
  rs <- c(0.1, 0.3, 0.5)
  nvals <- seq(8, 1000, length.out=1000)
  
  greenscols<-brewer.pal(9, "Greens")
  greenscols3<-c(greenscols[3],greenscols[6],greenscols[9])
  
  plot(nvals, seq(0,1, length.out=length(nvals)), xlab="Sample Size", ylab="Power",
       main="Power Curve for Standard Correlation", type="n")
  for (i in 1:3) 
    {
    powvals <<- sapply(nvals, function (x) pwr.r.test(n=x, r=rs[i])$power)
    lines(nvals, powvals, lwd=2.5, col=greenscols3[i])
    }
  legend("bottomright", lwd=2, col=greenscols3, legend=c("0.1", "0.3", "0.5"))
  abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)
```




