---
title: "Reproduce results of rmcorr paper"
author: "Jon Bakdash and Laura Marusich"
date: "June 8, 2016"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
require(pwr)
require(psych) 
require(Hmisc)
require(RColorBrewer)
require(grDevices)
require(plotrix)
require(metafor)
library(rmcorr)
require(devtools) #Comment out in final version
require(lme4)
require(AICcmodavg)
require(MuMIn)
#install_github('lmarusich/rmcorr')

#require(checkpoint)
#checkpoint("2016-XX-YY") #Won't work yet b/c rmcorr doesn't yet exist in CRAN
#require(memoise)
addalpha <- function(colors, alpha=1.0) {
  r <- col2rgb(colors, alpha=T)
  # Apply alpha
  r[4,] <- alpha*255
  r <- r/255.0
  return(rgb(r[1,], r[2,], r[3,], r[4,]))
}

# colorRampPaletteAlpha()
colorRampPaletteAlpha <- function(colors, n=32, interpolate='linear') {
  # Create the color ramp normally
  cr <- colorRampPalette(colors, interpolate=interpolate)(n)
  # Find the alpha channel
  a <- col2rgb(colors, alpha=T)[4,]
  # Interpolate
  if (interpolate=='linear') {
    l <- approx(a, n=n)
  } else {
    l <- spline(a, n=n)
  }
  l$y[l$y > 255] <- 255 # Clamp if spline is > 255
  cr <- addalpha(cr, l$y/255.0)
  return(cr)
}

```

###1. Figure 1: rmcorr and reg plot
```{r, echo = FALSE, warning = FALSE, results =  "hide", fig.height = 6, fig.width = 12}
set.seed(50)

initX <- rnorm(50)
newY <- NULL
newX <- NULL
sub <- rep(1:10, each = 5)

rsq <- .9

addy <- 6
addx <- -2
for (i in 1:10){
  addy <- addy - 1
  addx <- addx + .25
  tempData <- initX[sub == i] + addx
  sdx <- sd(tempData)
  sdnoise <- sdx * (sqrt((1-rsq)/rsq))
  tempy <- tempData + rnorm(5,0,sdnoise) + rnorm(1,addy,3)
  newY <- c(newY, tempy)
  newX <- c(newX,tempData)
}

exampleMat <-data.frame(cbind(sub,newX,newY))
example.rmc <- rmcorr(sub,newX,newY,exampleMat)

###standard averaged regression plot
submeanx <- aggregate(exampleMat$newX, by = list(exampleMat$sub), mean)
submeany <- aggregate(exampleMat$newY, by = list(exampleMat$sub), mean)
mypal <- colorRampPalette(RColorBrewer::brewer.pal(10,'Paired'))
cols <- mypal(10)

par(mfrow = c(1, 2), mgp = c(2.5, .75, 0), mar = c(4,4,2,1), cex = 1.2)

plot(example.rmc, exampleMat, xlab = "x", ylab = "y", main = "a) Rmcorr Plot",
     overall = F, palette = mypal, las = 1)
text(-3,-8,paste('rmcorr =', round(example.rmc$r,2),'\np < 0.001'), adj = 0)

plot(submeanx[,2], submeany[,2], pch = 16, col = cols, main = "b) Regression Plot", 
     xlab = "x (averaged for each participant)",
     ylab = "y (averaged for each participant)", las = 1)
stdr <- cor.test(submeanx[,2], submeany[,2])
text(-1.75,-7,paste('r =', round(stdr$est,2),'\np =', round(stdr$p.value,2)), adj = 0)
abline(lm(submeany[,2]~submeanx[,2]),col="gray50")

dev.copy(pdf, file="plots/Figure1_Rmcorr_vs_reg.pdf", 9, 6)
dev.off()

```

###2. Figure 2: rmcorr w/data transformations
```{r, echo = FALSE, warning = FALSE, results = "hide", fig.height = 6, fig.width = 12}
set.seed(10)
initX <- rnorm(15)
newY <- NULL
newX <- NULL
sub <- rep(1:3, each = 5)
rsq <- .7
addy <- 4
addx <- -2
for (i in 1:3){
  addy <- addy - 1
  addx <- addx + .25
  
  tempData <- initX[sub == i] + addx
  sdx <- sd(tempData)
  sdnoise <- sdx * (sqrt((1-rsq)/rsq))
  tempy <- tempData + rnorm(5,0,sdnoise) + rnorm(1,addy,1)
  newY <- c(newY, tempy)
  newX <- c(newX,tempData)
}

par(mfrow=c(1,3), mar = c(4,4,2,2), mgp = c(2.75, .75, 0), cex = 1.2)

###original plot
exampleMat <-data.frame(cbind(sub,newX,newY))
example.rmc <- rmcorr(sub,newX,newY,exampleMat)

mypal <- colorRampPalette(RColorBrewer::brewer.pal(10,'Paired'))
cols <- mypal(10)

plot(example.rmc, exampleMat, xlab = "x", ylab = "", main = "a) Original",
     overall = F, palette = mypal, xlim = c(-3.5, 1), ylim = c(-2.25,2), las = 1)
text(-3.5,1.75,paste('rmcorr =', round(example.rmc$r,2),'\np < 0.001'), adj = 0)
mtext(side = 2, "y", las = 1, line = 2.5, cex = 1.2)

###add 1 to all x's, multiply by 2
exampleMat2 <- exampleMat
exampleMat2$newX <- exampleMat2$newX * .5 + 1
example2.rmc <- rmcorr(sub, newX, newY, exampleMat2)
plot(example2.rmc, exampleMat2, xlab = "x", ylab = "", main = "b) x / 2 + 1", overall = F,
     palette = mypal, xlim = c(-3.5, 1), ylim = c(-2.25,2), las = 1)
text(-3.5,1.75,paste('rmcorr =', round(example2.rmc$r,2),'\np < 0.001'), adj = 0)
mtext(side = 2, "y", las = 1, line = 2.5, cex = 1.2)

###just add -2 to sub3's ys
exampleMat3 <- exampleMat
exampleMat3$newY[11:15] <- exampleMat3$newY[11:15] - 2
example3.rmc <- rmcorr(sub, newX, newY, exampleMat3)
plot(example3.rmc, exampleMat3, xlab = "x", ylab = "", main = "c) Subject 3: y - 2", overall = F,
     palette = mypal, xlim = c(-3.5, 1), ylim = c(-2.25,2), las = 1)
text(-3.5,1.75,paste('rmcorr =', round(example3.rmc$r,2),'\np < 0.001'), adj = 0)
mtext(side = 2, "y", las = 1, line = 2.5, cex = 1.2)

dev.copy(pdf, file="plots/Figure2_Transformations.pdf", 12, 6)
dev.off()
```

###3. Figure 3: rmcorr vs OLS reg
```{r, echo = FALSE, warning = FALSE, results = "hide", fig.height = 9, fig.width = 9}
par(mfrow = c(3,3), mar = c(1,1,.5,.5), mgp = c(2.5,.75,0), 
    oma = c(4,4,4,0), cex = 1.1)

makeminiplot <- function(subxs, sub.slope, intercept, constant=0, xax = "n", 
                         yax = "n", legend = F){
  
  mypal <- colorRampPalette(RColorBrewer::brewer.pal(3,'Set1'))
  cols <- mypal(3)
  
  subys <- list(3)
  for (i in 1:3){
    subys[[i]] <- subxs[[i]] * sub.slope + intercept*i + constant
  }
  
  plot(subxs[[1]],subys[[1]], type = "n", xlim =c(0,4), ylim = c(0,10), 
       xlab = "", ylab = "", xaxt = xax, yaxt = yax, las = 1)
  
  allx <- unlist(subxs)
  ally <- unlist(subys)
  abline(lm(ally~allx))
  
  for (i in 1:3) {
    lines(subxs[[i]],subys[[i]], type = "o", col = cols[i], pch = 16)
  }
  
  if (legend) legend('bottomright', legend = "OLS", lwd = 1.25, bty = "n",
                     cex = 1.05, inset = .01)
}

subxs <- list(3)
subxs[[1]] <- seq(0,2,.25)
subxs[[2]] <- seq(1,3,.25)
subxs[[3]] <- seq(2,4,.25)

#ols is positive
makeminiplot(subxs, -1, 4, yax = "s", legend = T)
makeminiplot(subxs, 0, 2.75)
makeminiplot(subxs, 1, 1.5)

#ols is flat
makeminiplot(subxs, -1.5, 2.45, 3, yax = "s")
makeminiplot(subxs, 0, 0, 5)
makeminiplot(subxs, 1.5, -2.4, 7)

#ols is negative
makeminiplot(subxs, -.75, -2, 10, yax = "s", xax = "s")
makeminiplot(subxs, 0, -3.1, 10.9, xax = "s")
makeminiplot(subxs, .9, -4.6, 12, xax = "s")

mtext(side = 1, outer = T, line = 1.5, "x", at = c(.175, .5, .85))
mtext(side = 2, outer = T, line = 1.5, "y", at = c(.175, .5, .85), las = 1)
mtext(side = 3, outer = T, line = .5, 
      c("a) rmcorr = -1", "b) rmcorr = 0", "c) rmcorr = 1"),
      at = c(.175, .5, .85), las = 1, cex = 1.5)


dev.copy(pdf, file="plots/Figure3_Rmcorr_vs_OLS.pdf", 9, 9)
dev.off()

```

###4. Figure 4: Power curves 
```{r, echo=FALSE, fig.height = 8, fig.width = 8}
power.rmcorr<-function(k, N, effectsizer, sig)
{
  pwr.r.test(n = ((N)*(k-1))+1, r = effectsizer, sig.level = sig) 
  #df are specified this way because pwr.r.test assumes the input is N, so it uses N - 2 for the df
}

par(mfrow=c(1,3), cex.lab=1.25, cex.axis=1.25, cex.main=1.25, cex.sub=1.25, mar=c(4.5,4.5,1.75,1))

#Small effect size
k<-c(3, 5, 10, 20) 
nvals <- seq(6, 300)
powPearsonSmall <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.1)$power)

bluecolors<-c("#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594")
#bluecols<-brewer.pal(9, "Blues")
#bluecols3<-c(greenscols[6], bluecols[2],bluecols[3],bluecols[5],bluecols[7],bluecols[9])



plot(nvals, seq(0,1, length.out=length(nvals)), 
     main = expression(bold("a)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.10')), 
     xlab=expression(Sample~Size~"("*italic('N')*")"),
     yaxt = "n", ylab = "Power", las = 1, col = "white", 
     xlim=c(0,300))

yLabels <- seq(0, 1, 0.2)
axis(2, at=yLabels, labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1, cex.sub = 2)

for (i in 1:4) 
{
  powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.1, 0.05)$power)
  lines(nvals, powvals, lwd=2.5, col=bluecolors[i+1])
}
legend("bottomright", lwd=2.5, col=bluecolors, bty= 'n', legend=c("1", "3", "5", "10", "20"), title = expression(italic('k')),
       cex = 1.2)
lines(nvals, powPearsonSmall, col=bluecolors[1], lwd= 2.5)
abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)

#Medium effect size
k<-c(3, 5, 10, 20)
nvals <- seq(6, 50)
powPearsonMedium <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.3)$power)
greencolors<-c("#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#005a32")

#orangecols<-brewer.pal(9, "Oranges")
#orangecols3<-c(orangecols[2],orangecols[3],orangecols[5],orangecols[7],orangecols[9])

plot(nvals, seq(0,1, length.out=length(nvals)), 
     main = expression(bold("b)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.30')), 
     xlab=expression(Sample~Size~"("*italic('N')*")"),
     yaxt = "n", ylab = "Power", las = 1, col = "white", 
     xlim=c(0,50))

yLabels <- seq(0, 1, 0.2)
axis(2, at=yLabels, main = "Power", labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1)

for (i in 1:4) 
{
  powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.3, 0.05)$power)
  lines(nvals, powvals, lwd=2.5, col=greencolors[i+1])
}
legend("bottomright", lwd=2, col=greencolors, bty = 'n', legend=c("1", "3", "5", "10", "20"), title = expression(italic('k')),
       cex = 1.2)
lines(nvals, powPearsonMedium, col=greencolors[1], lwd = 2.5)
abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)

#Large effect size
k<-c(3, 5, 10, 20)
nvals <- seq(6, 30)
powPearsonlarge <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.5)$power)

purplecolors<-c("#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486")

plot(nvals, seq(0,1, length.out=length(nvals)), 
     main = expression(bold("c)")~bolditalic('r'[rm])~bold(and)~bolditalic(r)~bold('=')~ bold('0.50')),
     xlab=expression(Sample~Size~"("*italic('N')*")"),
     yaxt = "n", ylab = "Power", las = 1, col = "white", xlim=c(0,30))
yLabels <- seq(0, 1, 0.2)
axis(2, at=yLabels, main = "Power", labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1)

for (i in 1:4) 
{
  powvals <- sapply(nvals, function (x) power.rmcorr(k[i], x, 0.5, 0.05)$power)
  lines(nvals, powvals, lwd=2.5, col=purplecolors[i+2])
}
legend("bottomright", lwd=2, col=purplecolors, legend=c("1", "3", "5", "10", "20"), bty = 'n', title = expression(italic('k')),
       cex = 1.2)
abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)
lines(nvals, powPearsonlarge, col=purplecolors[2], lwd = 2.5)

dev.copy(pdf, file="plots/Figure4_Power_curves.pdf", 8, 8)
dev.off()

```

###5. Visual search rmcorr and simple reg/cor results and Figure 5
#### a) rmcorr and simple reg results
```{r, echo=FALSE}
vissearch.rmc <- rmcorr(participant = sub, measure1 = rt, measure2 = acc, dataset = gilden2010)
print(vissearch.rmc)

vissearch.lm<-lm(acc~rt, data = gilden2010)
print(vissearch.lm)

cor.test(gilden2010$rt, gilden2010$acc)
```

#### b) Figure 5: Visual search rmcorr and simple reg/cor
```{r, echo=FALSE, fig.width = 9, fig.height = 6}

par(mfrow=c(1,2), mar=c(5,4.6,4,0.5), mgp=c(3.2,0.8,0),  oma = c(0, 0, 0, 0), las = 1)

plot(vissearch.rmc, gilden2010, overall = F, xlab = "Reaction Time", ylab = "Accuracy", cex = 1.2, 
     main = expression(bold("a)")~bold('Rmcorr'))) 
axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

plot(acc~rt, data = gilden2010, xlab = "Reaction Time (seconds)", ylab = "Accuracy", cex = 1.2, pch = 16,
     main = ("b) Simple Regression/\nCorrelation"))
abline(vissearch.lm, col = "red", lwd = 2)
axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure5_Visual_Search.pdf", 9, 6)
dev.off()

```
###6. Brain volume and age rmcorr and simple reg/cor results and Figure 6
#### a) rmcorr and simple reg results
```{r, echo=FALSE}
#Note for details on Raz: Data captured from Figure 8, Cerebellar Hemispheres (lower right)
brainvolage.rmc <- rmcorr(participant = Participant, measure1 = Age, measure2 = Volume, dataset = raz2005)
print(brainvolage.rmc)

brainvolage.lm<-lm(Volume~Age, data = raz2005)
print(brainvolage.lm)

cor.test(raz2005$Age, raz2005$Volume)

#Reproduce correlations in the paper: Cross-sectional (correlation at Time 1)
Time1raz2005<-subset(raz2005, Time == 1)
Time2raz2005<-subset(raz2005, Time == 2)

cor.test(Time1raz2005$Age, Time1raz2005$Volume) #Table 4, second row from the bottom (CBH T1)


Changeraz2005<-(Time2raz2005-Time1raz2005)
cor.test(Changeraz2005$Age, Changeraz2005$Volume) #Table 4, last row (Change)
  
#Not in Raz paper, correlation between age and volume at Time 2
  cor.test(Time2raz2005$Age, Time2raz2005$Volume)

```

#### b) Figure 6: Brain vol + age, rmcorr and simple reg/cor
```{r, echo=FALSE, fig.width = 9, fig.height = 6}

par(mfrow=c(1,2), mar=c(5,4.6,4,0.5), mgp=c(3.2,0.8,0),  oma = c(0, 0, 0, 0), las = 1)


blueset <- brewer.pal(8, 'Blues')
pal <- colorRampPalette(blueset)
plot(brainvolage.rmc, raz2005, overall = F, palette = pal, ylab = expression(Cerebellar~Hemisphere~Volume~(cm^{3})), xlab = "Age", cex = 1.2, 
     main = expression(bold("a)")~bold('Rmcorr'))) 
axis.break(axis = 2, style = "slash")

plot(Volume~Age, data = raz2005, ylab = expression(Cerebellar~Hemisphere~Volume~(cm^{3})), xlab = "Age", cex = 1.2, pch = 16,
     main = ("b) Simple Regression/\nCorrelation"))
abline(brainvolage.lm, col = "red", lwd = 2)
axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure6_Volume_Age.pdf", 9, 6)
dev.off()

```

###7. Complete pooling examples (fit a single model to all data points) using regression: Size and Distance
##### a) Regression Results 
```{r, echo = FALSE}
SizeDistPoolAll.lm<-lm(Emmert_distance_meters~Perceived_dist, data = Size_distance)
print(SizeDistPoolAll.lm)
summary(SizeDistPoolAll.lm)

#Complete Pooling by block: Single model fit to data averaged by block, by participant 
BlockSizeDistance<-aggregate(cbind(Emmert_distance_meters, Perceived_dist) ~ Actual_dist_meters + Participant, FUN = mean, data=Size_distance)
SizeDistBlock.lm<-lm(Emmert_distance_meters~Perceived_dist , data = BlockSizeDistance)
print(SizeDistBlock.lm)
summary(SizeDistBlock.lm)
```

##### b) Figure 7
```{r, echo = FALSE}
par(mfrow=c(1,2), mar=c(5,4.6,4,0.5), mgp=c(3.2,0.8,0),  oma = c(0, 0, 0, 0), las = 1)

plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16, 
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "a) Complete Pooling: All Data",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance (m)", 
     las = 1) 
abline(SizeDistPoolAll.lm, col = "red", lwd = 2)
axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

SizeDistBlock.lm
plot(Emmert_distance_meters~Perceived_dist, data = BlockSizeDistance, pch = 16, 
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "b) Complete Pooling: \nAveraged by Block, by Participant",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance (m)", 
     las = 1) 
abline(SizeDistBlock.lm, col = "red", lwd = 2)
axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure7_CompletePooling.pdf", 9, 6)  
dev.off()
```  

###8. No pooling (no overall predictor, "separate" models for each participant) using regression: Size and distance 
##### a)  Multiple Regression: Different intercepts for each participant, common slope 
```{r, echo = FALSE}    
#No constant term (-1) so all participants are included 
SizeDistNoPool.lm<-lm(Emmert_distance_meters~Perceived_dist + factor(Participant) - 1, data = Size_distance)
print(SizeDistNoPool.lm)
summary(SizeDistNoPool.lm)

# #Separate models for each actual dist, quasi-piecewise/segmented regression  
Break2<-subset(Size_distance, Actual_dist_meters == 2)
Break4<-subset(Size_distance, Actual_dist_meters == 4)
Break6<-subset(Size_distance, Actual_dist_meters == 6)

SizeDistNoPoolBreak2.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break2)
print(SizeDistNoPoolBreak2.lm)
summary(SizeDistNoPoolBreak2.lm)

SizeDistNoPoolBreak4.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break4)
print(SizeDistNoPoolBreak4.lm)
summary(SizeDistNoPoolBreak4.lm)

SizeDistNoPoolBreak6.lm<-lm(Emmert_distance_meters~ Perceived_dist, data = Break6)
print(SizeDistNoPoolBreak6.lm)
summary(SizeDistNoPoolBreak6.lm)


plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16,
     col=rgb(red = 0.0, green = 0.0, blue = 0.0, alpha = 0.3),
     main = "Separate Regressions of Actual Distance:\n Emmert Distance and Perceived Distance",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)",
     las = 1)
curve(1.5336 + 0.2851*x, add = TRUE, from = min(Break2$Perceived_dist), to = max(Break2$Perceived_dist))
curve(3.0811 + 0.3387*x, add = TRUE, from = min(Break4$Perceived_dist), to = max(Break4$Perceived_dist))
curve(5.6731 + 0.1786*x, add = TRUE, from = min(Break6$Perceived_dist), to = max(Break6$Perceived_dist))
```

##### b) Figure 8
```{r, echo = FALSE, fig.width = 8, fig.height = 8}
#Wish list: Each regression line clipped by range of participant data, color of points and lines matched to participant 
subs <- unique(Size_distance$Participant)
cols <- gray(1:length(subs)/length(subs))

plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, pch = 16, 
     col=addalpha(cols[match(Size_distance$Participant, subs)], 0.65),
     main = "No Pooling:\nRegression of Emmert Distance and Perceived Distance",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", 
     las = 1) 
#Unique intercept per participant, the same slope

preds <- predict(SizeDistNoPool.lm)
for (i in 1:length(subs)){
    subindex <- which(Size_distance$Participant == subs[i])
    lines(Size_distance$Perceived_dist[subindex], preds[subindex], col = cols[i])
}

axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure8_NoPooling.pdf", 8, 8)  
dev.off()


#Separate models: Separate regression for each participant (another form of no pooling), 
#same as above except each individual has their own slope 
```

###9. Emmert Distance (size) and distance rmcorrs 
##### a) Three separate rmcorr
```{r, echo=TRUE}

#Subset the data first
Size_distance_actual2<-subset(Size_distance, Actual_dist_meters==2)
Size_distance_actual4<-subset(Size_distance, Actual_dist_meters==4)   
Size_distance_actual6<-subset(Size_distance, Actual_dist_meters==6)

#Seperate rmcorr on each actual distance (factor level)
Distance_EmmertDist2.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, measure2 = Emmert_distance_meters, dataset = Size_distance_actual2)
Distance_EmmertDist2.rmc

Distance_EmmertDist4.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, 
                                 measure2 = Emmert_distance_meters, dataset = Size_distance_actual4)
Distance_EmmertDist4.rmc

Distance_EmmertDist6.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, 
                                 measure2 = Emmert_distance_meters, dataset = Size_distance_actual6)
Distance_EmmertDist6.rmc
```

##### b) Figure 9: Emmert Distance (size) and distance rmcorrs 
```{r, echo=FALSE, fig.width = 10, fig.height = 5}

par(mfrow=c(1,3), cex.lab=1.1, cex.axis=1.1, cex.main=1.1, cex.sub = 1.1, mgp=c(3.2,0.8,0))
#par(mfrow=c(1,3), mar=c(5,5,4,0.75), oma=c(0,2,0,0), mgp=c(3.2,0.80,0), cex.lab=1.2, cex.axis=1.1, cex.main=1.2, cex.sub=1.15)

Blues<-(brewer.pal(9,'Blues'))
pal1<-colorRampPalette(Blues)

Oranges<-(brewer.pal(9,'Oranges'))
pal2<-colorRampPalette(Oranges)

Greens<-(brewer.pal(9,'Greens'))
pal3<-colorRampPalette(Greens)

plot(Distance_EmmertDist2.rmc, Size_distance_actual2, overall = FALSE,
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(1,3), xlim = c(1,3), palette = pal1,
     main = ("a) Actual Distance\n2m"), cex = 1.2)
axis.break(axis = 1, style = "slash", brw = 0.0125)
axis.break(axis = 2, style = "slash", brw = 0.0125)

plot(Distance_EmmertDist4.rmc, Size_distance_actual4, overall = FALSE,       
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(2,7), xlim = c(2,6), palette = pal2,
     main = ("b) Actual Distance\n4m"), cex = 1.2)
axis.break(axis = 1, style = "slash", brw = 0.0125)
axis.break(axis = 2, style = "slash", brw = 0.0125)

plot(Distance_EmmertDist6.rmc, Size_distance_actual6, overall = FALSE, 
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", las = 1, ylim = c(2,11), xlim = c(3,9), palette = pal3,
     main = ("c) Actual Distance\n6m"), cex = 1.2)
axis.break(axis = 1, style = "slash", brw = 0.0125)
axis.break(axis = 2, style = "slash", brw = 0.0125)

dev.copy(pdf, file="plots/Figure9_size_dist_sep.pdf", 10, 5)     
dev.off()  

```

###10. Forest plot of separate rmcorrs 
```{r, echo=FALSE, fig.width = 9, fig.height = 6}

yi<-c(Distance_EmmertDist2.rmc$r, Distance_EmmertDist4.rmc$r, Distance_EmmertDist6.rmc$r)
ni<-rep(101, length.out = 3)
effectlabels<-c("Actual Distance 2m","Actual Distance 4m", "Actual Distance 6m")
DistMeta<-data.frame(cbind(effectlabels, as.numeric(yi), as.numeric(ni)))

#Parametric Confidence Intervals
dev <-escalc(ri = yi, ni = ni, measure="ZCOR", method ="REML", data = DistMeta, append = FALSE)
devRE <- rma(yi, vi, data = dev)
confint(devRE)
summary(devRE)

Figure7<-forest(devRE, slab = effectlabels, mlab = "Overall (Random Effects Model)",
                xlab = expression("Repeated Measures Correlation Coefficient"~"("*italic('r'[rm])*")")) 
text(-0.88, 5, "Factor Level", pos = 1, font = 2)
text(0.70, 5, expression(italic(r)[rm] ~~ "[95% CI]"), pos = 1, font = 2)

dev.copy(pdf, file="plots/Figure10_Forest.pdf", 9, 6)  
dev.off()

```

###11. Complete pooling of size and distance using rmcorr overall (ignoring factor levels of actual distance) 
##### a) rmcorr results
```{r, echo=FALSE}
#Seperate rmcorr on each actual distance (factor level)
Distance_EmmertDist_Overall.rmc<-rmcorr(participant = Participant, measure1 = Perceived_dist, measure2 = Emmert_distance_meters, dataset = Size_distance)
Distance_EmmertDist_Overall.rmc
```

##### b) Figure 11: rmcorr FLOP 
```{r, echo=FALSE, fig.width = 9, fig.height = 6}
pal4<-colorRampPalette(brewer.pal(9,"Reds"))

par(cex.lab=1.2, cex.axis=1.2, cex.main=1.2, cex.sub=1.2, mar=c(6,5.5,4,3.5), oma=c(1,1,1,1), mgp = c(4, 1, 0))
Figure8<-plot(Distance_EmmertDist_Overall.rmc, Size_distance, overall = FALSE,
              ylab = "Emmert Distance (m)",
              xlab = "Perceived Distance\n(m)", las = 1, palette = pal4,
              main = ("Rmcorr Ignoring Factor Levels"))
axis.break(axis = 1, style = "slash")
axis.break(axis = 2, style = "slash")

dev.copy(pdf, file="plots/Figure11_FLOP_rm_overall.pdf", 9, 6)  
dev.off()

```

###12. Multi-level modeling of size and distance data 
##### Multi-level modeling and model comparison
```{r, echo=FALSE}

#Knitting the Rmd throws errors with data = ... in lmer, even though it works fine as a script. No clue why????
#NullModel<-lmer(Emmert_distance_meters ~  1 + (1|Participant), data = Size_distance, REML = FALSE)
#Note actual_dist_meters has only 3 levels, very spare for random effect. Not specified as an RE here.

#Clunky Rmd safe version
#Random Int (Participant) only
NullModel<- lmer(Size_distance$Emmert_distance_meters ~  1 + (1 | Size_distance$Participant), REML = FALSE)

#Model 1: Null + fixed effect actual distance
Model1 <- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters + 
              (1|Size_distance$Participant), 
              REML = FALSE)

#Model 2: Model 1 + fixed effect perceived distance  
Model2 <- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters + Size_distance$Perceived_dist + 
              (1|Size_distance$Participant), 
              REML = FALSE)

#Model 3: Model 2 + fixed effect actual distance x  perceived dist (fully crossed)
Model3 <- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist + 
              (1|Size_distance$Participant), 
              REML = FALSE)

#Model X: Doesn't converge
# ModelX <- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist + 
#               (1 + Size_distance$Perceived_dist|Size_distance$Participant), 
#               REML = FALSE)

#Model4: Fully crossed fixed effects, RE slope for perceived dist by participant (does not converge with correlated slope)
Model4<- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist + 
              (-1 + Size_distance$Perceived_dist|Size_distance$Participant) + (1|Size_distance$Participant), 
              REML = FALSE)

#ModelY: Model 4 + RE int by participant (intercept ends up being zero), so it is the same as Model4 
# ModelY<- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist + 
#               (-1 + Size_distance$Perceived_dist|Size_distance$Participant) + (1|Size_distance$Participant), 
#               REML = FALSE)

#ModelZ: Amazing this even converges b/c actual dist has only 3 levels, not enough to be an RE. 
#Fully crossed fixed effects. RE correlated int by participants, RE slopes for perceived dist and actual dist.
# ModelZ<- lmer(Size_distance$Emmert_distance_meters ~ Size_distance$Actual_dist_meters*Size_distance$Perceived_dist +
#               (1 + Size_distance$Perceived_dist + Size_distance$Actual_dist_meters|Size_distance$Participant),
#               REML = FALSE)

#Model Comparison
anova(NullModel, Model1, Model2, Model3, Model4)

SizeDistModels<-list()
SizeDistModels[1:5]<-c(NullModel, Model1, Model2, Model3, Model4)

ModelTable<-aictab(SizeDistModels, modnames = c("Null", "Model 1", "Model 2", "Model 3", "Model 4"))
ModelTable
evidence(ModelTable)

#Pseudo R2s
r.squaredGLMM(Model4)

```

##### b) Figure 12 --Graph the best fit model-- Model 4 
```{r, echo=FALSE, fig.width = 9, fig.height = 6}
plot(Emmert_distance_meters~Perceived_dist, data = Size_distance, type = "n", 
     main = "Best Fit Multilevel Model",
     ylab = "Emmert Distance (m)",
     xlab = "Perceived Distance\n(m)", 
     las = 1) 

getranges<-function(readdata) 
{
  XYRange<<-range(readdata["Perceived_dist"])
}

#Get predicted values 
PercDistModel4<-predict(Model4)
SeqParticipant<- rep(1:20, each = 2, times = 9)
SizeDistMod4<-cbind(SeqParticipant, Size_distance, PercDistModel4)
SizeDistBestFit<-SizeDistMod4[order(SeqParticipant, SizeDistMod4$PercDistModel4),]

#Plot OVerall (Level 2) fixed effects w/o discont
FixedEffectsMod4<-fixef(Model4)
SlopeFE<-FixedEffectsMod4[2]+FixedEffectsMod4[3]+FixedEffectsMod4[4]
getranges(SizeDistBestFit)
ablineclip(FixedEffectsMod4[1], SlopeFE, col = "black",  x1 = XYRange[1], 
           x2 = XYRange[2], lwd = 2)

#Plot random effects
PlotRE<- function(N, length, PredictData, cols) 
{
  for (i in 1:N) 
  {
    Extract<-1+(i-1)*length  #Starts at 1, then goes to 7, 13, ..., 115 
    lines(spline(PredictData[Extract:(length*i), 6],PredictData[Extract:(length*i), 11]), col = cols[i])
  }
}

#Plot Overall fixed effects w/discont
#Actual distance has a mean = 4, sd = 2 
Preds <- list()
Ints <- list()
Slopes <- list()

pals <- c('Blues', 'Oranges', 'Greens')
subs <- unique(Size_distance$Participant)
for (i in 1:3){
  
  tempDat <- Size_distance[Size_distance$Actual_dist_meters == i*2, ]
  cols <- addalpha(colorRampPalette(brewer.pal(9, pals[i]))(length(subs)), .6)
  points(Emmert_distance_meters~Perceived_dist, data = tempDat, pch = 16, 
         col=cols[match(tempDat$Participant, subs)])
  
  Preds[[i]] <- subset(SizeDistBestFit,Actual_dist_meters == i*2)
  Ints[[i]] <- FixedEffectsMod4[1]+FixedEffectsMod4[2]*(i*2)
  Slopes[[i]] <- FixedEffectsMod4[3]+FixedEffectsMod4[4]*(2 * (i - 2))
  
  getranges(Preds[[i]])
  ablineclip(Ints[[i]], Slopes[[i]], col = "gray40", lty = 2, x1 = XYRange[1]-.2, 
             x2 = XYRange[2]+.2, lwd = 2)
  
  PlotRE(length(subs), 6, Preds[[i]], cols)
  
}

dev.copy(pdf, file="plots/Figure12_multilevel_model.pdf", 9, 6)  
dev.off()
```

##Appendix: Rmcorr minus standard corr power 

```{r, echo=FALSE}
k<-2
nvals <- seq(8, 250)
powPearsonLarge <- sapply(nvals, function (x) pwr.r.test(n=x, r=0.5)$power)
#bluecolors<-c("#c6dbef", "#9ecae1")

par(mfrow=c(1,1), cex.lab=1.1, cex.axis=1.1, cex.main=1.2, cex.sub=1.2)
AppendFig1<-plot(nvals, seq(0,1, length.out=length(nvals)), 
                 xlab="Sample Size", yaxt = "n", ylab = paste("Power Difference:",  "Rmcorr (k = 2)", " -", " Pearson correlation"), las = 1, col = "white", xlim=c(0,250), ylim=c(0,0.05))
yLabels <- seq(0, 0.2, 0.01)
axis(2, at=yLabels, labels=sprintf(round(100*yLabels), fmt="%2.0f%%"), las=1, cex.sub = 2)

powvals <- sapply(nvals, function (x) power.rmcorr(k[1], x, 0.5, 0.05)$power)
powvalsdiff<-as.numeric(powvals) - as.numeric(powPearsonLarge)
lines(nvals, powvalsdiff, lwd=2.5, col="red")

dev.copy(pdf, file="plots/Appendix_Figure.pdf", 9, 6) 
dev.off()
``` 

## Standard Correlation Power Curve (not in paper)
```{r, echo=FALSE}
rs <- c(0.1, 0.3, 0.5)
nvals <- seq(8, 1000, length.out=1000)

greenscols<-brewer.pal(9, "Greens")
greenscols3<-c(greenscols[3],greenscols[6],greenscols[9])

plot(nvals, seq(0,1, length.out=length(nvals)), xlab="Sample Size", ylab="Power",
     main="Power Curve for Standard Correlation", type="n")
for (i in 1:3) 
{
  powvals <<- sapply(nvals, function (x) pwr.r.test(n=x, r=rs[i])$power)
  lines(nvals, powvals, lwd=2.5, col=greenscols3[i])
}
legend("bottomright", lwd=2, col=greenscols3, legend=c("0.1", "0.3", "0.5"))
abline(a = 0.8, b=0, col=1, lty=2, lwd= 2.5)
```




